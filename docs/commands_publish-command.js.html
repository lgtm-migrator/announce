<!DOCTYPE html>
<html lang="en">

	<head>
		<meta charset="utf-8">
		<title>commands/publish-command.js - Announce CLI - API Reference</title>
		<meta name="description" content="Announce CLI - API Reference" />
		<meta name="keywords" content="automation announce changelog cli console git github gitlab npm package publish release release-automation release-helper release-workflow semantic-release semantic-version semver semver-release terminal twyr version" />
		<meta name="keyword" content="automation announce changelog cli console git github gitlab npm package publish release release-automation release-helper release-workflow semantic-release semantic-version semver semver-release terminal twyr version" />
		<script src="scripts/prettify/prettify.js"></script>
		<script src="scripts/prettify/lang-css.js"></script>
		<!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
		<link type="text/css" rel="stylesheet" href="styles/prettify.css">
		<link type="text/css" rel="stylesheet" href="styles/jsdoc.css">
		<script src="scripts/nav.js" defer></script>
		<meta name="viewport" content="width=device-width, initial-scale=1.0">
	</head>

	<body>
		<input type="checkbox" id="nav-trigger" class="nav-trigger" />
		<label for="nav-trigger" class="navicon-button x">
			<div class="navicon"></div>
		</label>
		<label for="nav-trigger" class="overlay"></label>
		<nav class="wrap">
			<input type="text" id="nav-search" placeholder="Search" />
			<h2><a href="index.html">Home</a></h2>
			<h2><a href="https://github.com/twyr/announce" target="_blank" class="menu-item" id="github_link">GitHub</a></h2>
			<h3>Classes</h3>
			<ul>
				<li><a href="PrepareCommandClass.html">PrepareCommandClass</a>
					<ul class='methods'>
						<li data-type='method'><a href="PrepareCommandClass.html#_bumpVersion">_bumpVersion</a></li>
						<li data-type='method'><a href="PrepareCommandClass.html#_computeNextVersion">_computeNextVersion</a></li>
						<li data-type='method'><a href="PrepareCommandClass.html#_getCurrentVersion">_getCurrentVersion</a></li>
						<li data-type='method'><a href="PrepareCommandClass.html#_getTargetFileList">_getTargetFileList</a></li>
						<li data-type='method'><a href="PrepareCommandClass.html#_mergeOptions">_mergeOptions</a></li>
						<li data-type='method'><a href="PrepareCommandClass.html#_setupLogger">_setupLogger</a></li>
						<li data-type='method'><a href="PrepareCommandClass.html#execute">execute</a></li>
					</ul>
				</li>
				<li><a href="PublishCommandClass.html">PublishCommandClass</a>
					<ul class='methods'>
						<li data-type='method'><a href="PublishCommandClass.html#_getFromGithub">_getFromGithub</a></li>
						<li data-type='method'><a href="PublishCommandClass.html#_getReleaseAssetInformation">_getReleaseAssetInformation</a></li>
						<li data-type='method'><a href="PublishCommandClass.html#_getUpstreamRepositoryInfo">_getUpstreamRepositoryInfo</a></li>
						<li data-type='method'><a href="PublishCommandClass.html#_mergeOptions">_mergeOptions</a></li>
						<li data-type='method'><a href="PublishCommandClass.html#_publishToNpm">_publishToNpm</a></li>
						<li data-type='method'><a href="PublishCommandClass.html#_setupLogger">_setupLogger</a></li>
						<li data-type='method'><a href="PublishCommandClass.html#execute">execute</a></li>
					</ul>
				</li>
				<li><a href="ReleaseCommandClass.html">ReleaseCommandClass</a>
					<ul class='methods'>
						<li data-type='method'><a href="ReleaseCommandClass.html#_generateChangelog">_generateChangelog</a></li>
						<li data-type='method'><a href="ReleaseCommandClass.html#_generateReleaseNotes">_generateReleaseNotes</a></li>
						<li data-type='method'><a href="ReleaseCommandClass.html#_initializeGit">_initializeGit</a></li>
						<li data-type='method'><a href="ReleaseCommandClass.html#_mergeOptions">_mergeOptions</a></li>
						<li data-type='method'><a href="ReleaseCommandClass.html#_pushUpstream">_pushUpstream</a></li>
						<li data-type='method'><a href="ReleaseCommandClass.html#_releaseCode">_releaseCode</a></li>
						<li data-type='method'><a href="ReleaseCommandClass.html#_setupLogger">_setupLogger</a></li>
						<li data-type='method'><a href="ReleaseCommandClass.html#_stashOrCommit">_stashOrCommit</a></li>
						<li data-type='method'><a href="ReleaseCommandClass.html#_tagCode">_tagCode</a></li>
						<li data-type='method'><a href="ReleaseCommandClass.html#execute">execute</a></li>
					</ul>
				</li>
			</ul>
		</nav>
		<div id="main">
			<h1 class="page-title">commands/publish-command.js</h1>
			<section>
				<article>
					<pre class="prettyprint source linenums"><code>/* eslint-disable security/detect-object-injection */
/* eslint-disable security/detect-non-literal-fs-filename */
/* eslint-disable security/detect-non-literal-regexp */
/* eslint-disable security/detect-non-literal-require */
/* eslint-disable security-node/detect-crlf */
/* eslint-disable security-node/detect-non-literal-require-calls */
/* eslint-disable security-node/non-literal-reg-expr */
'use strict';

/**
 * Module dependencies, required for ALL Twy'r modules
 * @ignore
 */

/**
 * Module dependencies, required for this module
 * @ignore
 */
const debugLib = require('debug');
const debug = debugLib('announce:publish');

/**
 * @class		PublishCommandClass
 * @classdesc	The command class that handles all the publish operations.
 *
 * @param		{object} configuration - The configuration object containing the command options from the config file (.announcerc, package.json, etc.)
 *
 * @description
 * The command class that implements the "publish" step of the workflow.
 * Please see README.md for the details of what this step involves.
 *
 */
class PublishCommandClass {
	// #region Constructor
	constructor(configuration) {
		Object.defineProperty(this, '_commandOptions', {
			'writeable': true,
			'value': configuration ?? {}
		});
	}
	// #endregion

	// #region Public Methods
	/**
	 * @async
	 * @function
	 * @instance
	 * @memberof PublishCommandClass
	 * @name     execute
	 *
	 * @param    {object} options - Parsed command-line options, or options passed in via API
	 *
	 * @return {null} Nothing.
	 *
	 * @summary  The main method to publish the Github release to NPM.
	 *
	 * This method does 2 things:
	 * - Gets the URL to the compressed asset for the last/specified release from Github
	 * - Publishes the asset to NPM
	 *
	 */
	async execute(options) {
		// Step 1: Setup sane defaults for the options
		const mergedOptions = this._mergeOptions(options);

		// Step 2: Set up the logger according to the options passed in
		const logger = this._setupLogger(mergedOptions);

		// Step 3: Get the upstream repository information - this is the one where the to-be-published release assets are hosted.
		const repository = await this._getUpstreamRepositoryInfo(mergedOptions, logger);

		// Step 4: Get the details of the to-be-published release from Github
		const releaseToBePublished = await this._getReleaseAssetInformation(mergedOptions, logger, repository);

		// Step 5: Run the npm publish command with the specified options
		await this._publishToNpm(mergedOptions, logger, releaseToBePublished);
	}
	// #endregion

	// #region Private Methods
	/**
	 * @function
	 * @instance
	 * @memberof	PublishCommandClass
	 * @name		_mergeOptions
	 *
	 * @param		{object} options - Parsed command-line options, or options passed in via API
	 *
	 * @return		{object} Merged options - input options > configured options.
	 *
	 * @summary  	Merges options passed in with configured ones - and puts in sane defaults if neither is available.
	 *
	 */
	_mergeOptions(options) {
		const path = require('path');
		const projectPackageJson = path.join(process.cwd(), 'package.json');
		const pkg = require(projectPackageJson);

		const mergedOptions = options ?? {};
		mergedOptions.execMode = this?._commandOptions?.execMode ?? 'cli';

		mergedOptions.debug = options?.debug ?? (options?.parent?.debug ?? false);
		mergedOptions.silent = options?.silent ?? (options?.parent?.silent ?? false);
		mergedOptions.quiet = options?.quiet ?? (options?.parent?.quiet ?? false);

		mergedOptions.quiet = mergedOptions.quiet || mergedOptions.silent;

		mergedOptions.access = options?.access ?? (this?._commandOptions?.access ?? 'public');
		mergedOptions.distTag = options?.distTag ?? (this?._commandOptions?.distTag ?? 'latest');
		mergedOptions.dryRun = options?.dryRun ?? (this?._commandOptions?.dryRun ?? false);

		mergedOptions.githubToken = options?.githubToken ?? (this?._commandOptions?.githubToken ?? process.env.GITHUB_TOKEN);
		mergedOptions.npmToken = options?.npmToken ?? (this?._commandOptions?.npmToken ?? process.env.NPM_TOKEN);

		mergedOptions.releaseName = options?.releaseName ?? (this?._commandOptions.releaseName ?? `V${pkg.version} Release`);
		mergedOptions.upstream = options?.upstream ?? (this?._commandOptions.upstream ?? 'upstream');

		return mergedOptions;
	}

	/**
	 * @function
	 * @instance
	 * @memberof	PublishCommandClass
	 * @name		_setupLogger
	 *
	 * @param		{object} options - merged options object returned by the _mergeOptions method
	 *
	 * @return		{object} Logger object with info / error functions.
	 *
	 * @summary  	Creates a logger in CLI mode or uses the passed in logger object in API mode - and returns it.
	 *
	 */
	_setupLogger(options) {
		const execMode = options?.execMode ?? 'cli';
		if(options?.debug) debugLib?.enable?.('announce:*');

		let logger = null;
		if((execMode === 'api') &amp;&amp; !options?.silent) { // eslint-disable-line curly
			logger = options?.logger;
		}

		if((execMode === 'cli') &amp;&amp; !options?.silent) {
			const Ora = require('ora');
			logger = new Ora({
				'discardStdin': true,
				'text': `Preparing...`
			});

			logger?.start?.();
		}

		return logger;
	}

	/**
	 * @async
	 * @function
	 * @instance
	 * @memberof	PublishCommandClass
	 * @name		_getUpstreamRepositoryInfo
	 *
	 * @param		{object} options - merged options object returned by the _mergeOptions method
	 * @param		{object} logger - Logger instance returned by the _setupLogger method
	 *
	 * @return		{object} POJO with information about the upstream repository URL, etc.
	 *
	 * @summary  	Instantiates a Git instance for the project, retrieves the upstream repository information, and returns a POJO with that info.
	 *
	 */
	async _getUpstreamRepositoryInfo(options, logger) {
		const execMode = options?.execMode ?? 'cli';

		const safeJsonStringify = require('safe-json-stringify');
		const simpleGit = require('simple-git');

		const git = simpleGit?.({
			'baseDir': process.cwd()
		})
		.outputHandler((_command, stdout, stderr) => {
			stderr.pipe(process.stderr);
		});

		debug(`initialized Git for the repository @ ${process.cwd()}`);
		// eslint-disable-next-line curly
		if(!options?.quiet) {
			if(execMode === 'api')
				logger?.debug?.(`initialized Git for the repository @ ${process.cwd()}. Fetching upstream repository information.`);
			else
				if(logger) logger.text = `Initialized Git for the repository @ ${process.cwd()}. Fetching upstream repository information...`;
		}

		const gitRemote = await git?.raw?.(['remote', 'get-url', '--push', options?.upstream]);

		const hostedGitInfo = require('hosted-git-info');
		const repository = hostedGitInfo?.fromUrl?.(gitRemote);
		repository.project = repository?.project?.replace?.('.git\n', '');

		if(execMode === 'api')
			logger?.info?.(`Fetched information for the ${repository.user}/${repository.project} upstream`);
		else
			logger?.succeed?.(`Fetched information for the ${repository.user}/${repository.project} upstream.`);

		debug(`repository info - ${safeJsonStringify(repository, null, '\t')}`);
		return repository;
	}

	/**
	 * @async
	 * @function
	 * @instance
	 * @memberof	PublishCommandClass
	 * @name		_getReleaseAssetInformation
	 *
	 * @param		{object} options - merged options object returned by the _mergeOptions method
	 * @param		{object} logger - Logger instance returned by the _setupLogger method
	 * @param		{object} repository - POJO containing information about the project/repo on Github hosting the assets
	 *
	 * @return		{object} POJO with information about the assets to-be-published.
	 *
	 * @summary  	Connects to the Github project pointed to in the configured upstream, retrieves information about the release to-be-published, and retuns that.
	 *
	 */
	async _getReleaseAssetInformation(options, logger, repository) {
		const execMode = options?.execMode ?? 'cli';

		debug(`retrieving ${options?.releaseName} release from github`);
		// eslint-disable-next-line curly
		if(!options?.quiet) {
			if(execMode === 'api')
				logger?.debug?.(`Retrieving ${options?.releaseName} release from Github`);
			else
				if(logger) logger.text = `Retrieving ${options?.releaseName} release from Github...`;
		}

		const githubReleases = await this?._getFromGithub?.(options, `https://api.${repository.domain}/repos/${repository.user}/${repository.project}/releases`);
		const releaseToBePublished = githubReleases?.filter?.((release) => { return (release?.name === options?.releaseName); })?.shift?.();

		if(!releaseToBePublished) throw new Error(`Unknown Release: ${options.releaseName}`);
		if(releaseToBePublished?.draft) throw new Error(`Cannot publish draft release: ${options.releaseName}`);

		if(execMode === 'api')
			logger?.debug?.(`Retrieved ${options?.releaseName} release from Github`);
		else
			logger?.succeed?.(`Retrieved ${options?.releaseName} release details from Github.`);

		debug(`retrieved ${options?.releaseName} release from github`);
		return releaseToBePublished;
	}

	/**
	 * @async
	 * @function
	 * @instance
	 * @memberof	PublishCommandClass
	 * @name		_publishToNpm
	 *
	 * @param		{object} options - merged options object returned by the _mergeOptions method
	 * @param		{object} logger - Logger instance returned by the _setupLogger method
	 * @param		{object} releaseToBePublished - POJO with information about the assets to-be-published
	 *
	 * @return		{null} Nothing.
	 *
	 * @summary  	Retrieves the release assets from Github, and publishes them to NPM.
	 *
	 */
	async _publishToNpm(options, logger, releaseToBePublished) {
		const execMode = options?.execMode ?? 'cli';

		debug(`publishing ${options?.releaseName} release to npm`);
		// eslint-disable-next-line curly
		if(!options?.quiet) {
			if(execMode === 'api')
				logger?.debug?.(`Publishing ${options?.releaseName} release to npm`);
			else
				if(logger) logger.text = `Publishing ${options?.releaseName} release to npm...`;
		}

		let distTag = null;

		// eslint-disable-next-line curly
		if((options?.distTag ?? 'version_default') === 'version_default') {
			if(releaseToBePublished?.prerelease)
				distTag = 'next';
			else
				distTag = 'latest';
		}

		const publishOptions = ['publish'];
		publishOptions?.push(releaseToBePublished?.tarball_url);
		publishOptions?.push?.(`--tag ${distTag}`);
		publishOptions?.push?.(`--access ${options.access}`);
		if(options?.dryRun) publishOptions?.push?.('--dry-run');

		const execa = require('execa');
		const publishProcess = execa?.('npm', publishOptions, {'all': true });
		publishProcess?.stdout?.pipe?.(process.stdout);
		publishProcess?.stderr?.pipe?.(process.stderr);

		await publishProcess;

		if(execMode === 'api')
			logger?.info?.(`Published ${options?.releaseName} release: npm ${publishOptions.join(' ')}`);
		else
			logger?.succeed?.(`Published ${options?.releaseName} release to npm.`);

		debug(`published ${options?.releaseName} release: npm ${publishOptions.join(' ')}`);
		return;
	}

	/**
	 * @async
	 * @function
	 * @instance
	 * @memberof	PublishCommandClass
	 * @name		 _getFromGithub
	 *
	 * @param		{object} options - merged options object returned by the _mergeOptions method
	 * @param		{string} url - the url giving the information we seek
	 *
	 * @return		{object} Hopefully, the required information from Github.
	 *
	 * @summary  	Given a Github REST API endpoint, call it and give back the information returned.
	 *
	 */
	async _getFromGithub(options, url) {
		const Promise = require('bluebird');

		return new Promise((resolve, reject) => {
			try {
				const octonode = require('octonode');
				const client = octonode?.client?.(options?.githubToken);
				debug('created client to connect to github');

				client?.get?.(url, {}, (err, status, body) => {
					if(err) {
						reject?.(err);
						return;
					}

					if(status !== 200) {
						reject?.(status);
						return;
					}

					resolve?.(body);
				});
			}
			catch(err) {
				reject?.(err);
			}
		});
	}
	// #endregion

	// #region Private Fields
	// #endregion
}

// Add the command to the cli
let commandObj = null;
exports.commandCreator = function commandCreator(commanderProcess, configuration) {
	if(!commandObj) commandObj = new PublishCommandClass(configuration?.publish);

	// Get package.json into memory... we'll use it in multiple places here
	const path = require('path');
	const projectPackageJson = path.join(process.cwd(), 'package.json');
	const { version } = require(projectPackageJson);

	commanderProcess
		.command('publish')
		.option('--access &lt;level>', 'Public / Restricted', 'public')
		.option('--dist-tag &lt;tag>', 'Tag to use for the published release', 'version_default')
		.option('--dry-run', 'Dry run publish', false)

		.option('-gt, --github-token &lt;token>', 'Token to use for accessing the release on Github', process.env.GITHUB_TOKEN)
		.option('-nt, --npm-token &lt;token>', 'Automation Token to use for publishing the release to NPM', process.env.NPM_TOKEN)

		.option('-rn, --release-name &lt;name>', 'Github release name for fetching the compressed assets', `V${version} Release`)
		.option('-u, --upstream &lt;remote>', 'Git remote to use for accessing the release', configuration?.publish?.upstream ?? 'upstream')

		.action(commandObj.execute.bind(commandObj));

	return;
};

// Export the API for usage by downstream programs
exports.apiCreator = function apiCreator() {
	if(!commandObj) commandObj = new PublishCommandClass({ 'execMode': 'api' });
	return {
		'name': 'publish',
		'method': commandObj.execute.bind(commandObj)
	};
};
</code></pre>
				</article>
			</section>
		</div>
		<br class="clear">
		<footer>
			Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.6.6</a> using the <a href="https://github.com/clenemt/docdash">docdash</a> theme.
		</footer>
		<script>
			prettyPrint();

		</script>
		<script src="scripts/polyfill.js"></script>
		<script src="scripts/linenumber.js"></script>
		<script src="scripts/search.js" defer></script>
	</body>

</html>
